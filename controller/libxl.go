/*
 * Copyright (C) 2016 George W. Dunlap, Citrix Systems UK Ltd
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; version 2 of the
 * License only.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */
package main

/*
#cgo LDFLAGS: -lxenlight -lyajl_s -lxengnttab -lxenstore -lxenguest -lxentoollog -lxenevtchn -lxenctrl -lblktapctl -lxenforeignmemory -lxencall -lz -luuid -lutil
#include <stdlib.h>
#include <libxl.h>
*/
import "C"

/*
 * Other flags that may be needed at some point: 
 *  -lnl-route-3 -lnl-3
 *
 * To get back to simple dynamic linking:
#cgo LDFLAGS: -lxenlight -lyajl
*/

import (
	"unsafe"
	"fmt"
	"time"
)

/*
 * Types: Builtins
 */

type Domid uint32

type MemKB uint64

// typedef struct {
//     uint32_t size;          /* number of bytes in map */
//     uint8_t *map;
// } libxl_bitmap;

// Implement the Go bitmap type such that the underlying data can
// easily be copied in and out.  NB that we still have to do copies
// both directions, because cgo runtime restrictions forbid passing to
// a C function a pointer to a Go-allocated structure which contains a
// pointer.
type Bitmap struct {
	bitmap []C.uint8_t
}

type Context struct {
	ctx *C.libxl_ctx
}

type Uuid C.libxl_uuid

/*
 * Types: IDL
 * 
 * FIXME: Generate these automatically from the IDL
 */
type Dominfo struct {
	Uuid              Uuid
	Domid             Domid
	Running           bool
	Blocked           bool
	Paused            bool
	Shutdown          bool
	Dying             bool
	Never_stop        bool
	
	Shutdown_reason   int32 // FIXME shutdown_reason enumeration
	Outstanding_memkb MemKB
	Current_memkb     MemKB
	Shared_memkb      MemKB
	Paged_memkb       MemKB
	Max_memkb         MemKB
	Cpu_time          time.Duration
	Vcpu_max_id       uint32
	Vcpu_online       uint32
	Cpupool           uint32
	Domain_type       int32 //FIXME libxl_domain_type enumeration

}

// # Consistent with values defined in domctl.h
// # Except unknown which we have made up
// libxl_scheduler = Enumeration("scheduler", [
//     (0, "unknown"),
//     (4, "sedf"),
//     (5, "credit"),
//     (6, "credit2"),
//     (7, "arinc653"),
//     (8, "rtds"),
//     ])
type Scheduler int
var (
	SchedulerUnknown  Scheduler = C.LIBXL_SCHEDULER_UNKNOWN
	SchedulerSedf     Scheduler = C.LIBXL_SCHEDULER_SEDF
	SchedulerCredit   Scheduler = C.LIBXL_SCHEDULER_CREDIT
	SchedulerCredit2  Scheduler = C.LIBXL_SCHEDULER_CREDIT2
	SchedulerArinc653 Scheduler = C.LIBXL_SCHEDULER_ARINC653
	SchedulerRTDS     Scheduler = C.LIBXL_SCHEDULER_RTDS
)

// libxl_cpupoolinfo = Struct("cpupoolinfo", [
//     ("poolid",      uint32),
//     ("pool_name",   string),
//     ("sched",       libxl_scheduler),
//     ("n_dom",       uint32),
//     ("cpumap",      libxl_bitmap)
//     ], dir=DIR_OUT)

type CpupoolInfo struct {
	Poolid uint32
	PoolName string
	Scheduler Scheduler
	DomainCount int
	Cpumap Bitmap
}

/*
 * Context
 */
var Ctx Context

func (Ctx *Context) IsOpen() bool {
	return Ctx.ctx != nil
}

func (Ctx *Context) Open() (err error) {
	if Ctx.ctx != nil {
		return
	}
	
	ret := C.libxl_ctx_alloc(unsafe.Pointer(&Ctx.ctx), C.LIBXL_VERSION, 0, nil)

	if ret != 0 {
		err = fmt.Errorf("Allocating libxl context: %d", ret)
	}
	return
}

func (Ctx *Context) Close() (err error) {
	ret := C.libxl_ctx_free(unsafe.Pointer(Ctx.ctx))
	Ctx.ctx = nil

	if ret != 0 {
		err = fmt.Errorf("Freeing libxl context: %d", ret)
	}
	return
}

func (Ctx *Context) DomainInfo(Id Domid) (di *Dominfo, err error) {
	if Ctx.ctx == nil {
		err = fmt.Errorf("Context not opened")
		return
	}

	var cdi C.libxl_dominfo

	ret := C.libxl_domain_info(Ctx.ctx, unsafe.Pointer(&cdi), C.uint32_t(Id))

	// FIXME: IsDomainNotPresentError
	if ret != 0 {
		err = fmt.Errorf("libxl_domain_info failed: %d", ret)
		return
	}

	// We could consider having this boilerplate generated by the
	// idl, in a function like this:
	//
	// di = translateCdomaininfoToGoDomaininfo(cdi)
	di = &Dominfo{}
	di.Uuid = Uuid(cdi.uuid)
	di.Domid = Domid(cdi.domid)
	di.Running = bool(cdi.running)
	di.Blocked = bool(cdi.blocked)
	di.Paused = bool(cdi.paused)
	di.Shutdown = bool(cdi.shutdown)
	di.Dying = bool(cdi.dying)
	di.Never_stop = bool(cdi.never_stop)
	di.Shutdown_reason = int32(cdi.shutdown_reason)
	di.Outstanding_memkb = MemKB(cdi.outstanding_memkb)
	di.Current_memkb = MemKB(cdi.current_memkb)
	di.Shared_memkb = MemKB(cdi.shared_memkb)
	di.Paged_memkb = MemKB(cdi.paged_memkb)
	di.Max_memkb = MemKB(cdi.max_memkb)
	di.Cpu_time = time.Duration(cdi.cpu_time)
	di.Vcpu_max_id = uint32(cdi.vcpu_max_id)
	di.Vcpu_online = uint32(cdi.vcpu_online)
	di.Cpupool = uint32(cdi.cpupool)
	di.Domain_type = int32(cdi.domain_type)

	return
}

func (Ctx *Context) DomainUnpause(Id Domid) (err error) {
	if Ctx.ctx == nil {
		err = fmt.Errorf("Context not opened")
		return
	}

	ret := C.libxl_domain_unpause(Ctx.ctx, C.uint32_t(Id))

	if ret != 0 {
		err = fmt.Errorf("libxl_domain_unpause failed: %d", ret)
	}
	return
}

/*
 * Bitmap operations
 */

// Return a Go bitmap which is a copy of the referred C bitmap.
func bitmapCToGo(cbm *C.libxl_bitmap) (gbm Bitmap) {
	// Alloc a Go slice for the bytes
	size := int(cbm.size)
	gbm.bitmap = make([]C.uint8_t, size)

	// Make a slice pointing to the C array
	mapslice := (*[1 << 30]C.uint8_t)(unsafe.Pointer(cbm._map))[:size:size]

	// And copy the C array into the Go array
	copy(gbm.bitmap, mapslice)

	return
}

// Must be C.libxl_bitmap_dispose'd of afterwards
func bitmapGotoC(gbm Bitmap) (cbm C.libxl_bitmap) {
	C.libxl_bitmap_init(&cbm)

	size := len(gbm.bitmap)
	cbm._map = (*C.uint8_t)(C.malloc(C.size_t(size)))
	cbm.size = C.uint32_t(size)
	if cbm._map == nil {
		panic("C.calloc failed!")
	}

	// Make a slice pointing to the C array
	mapslice := (*[1 << 30]C.uint8_t)(unsafe.Pointer(cbm._map))[:size:size]

	// And copy the Go array into the C array
	copy(mapslice, gbm.bitmap)

	return
}

func (bm *Bitmap) Test(bit int) (bool) {
	ubit := uint(bit)
	if (bit > bm.Max()) {
		return false
	}
	
	return (bm.bitmap[bit / 8] & (1 << (ubit & 7))) != 0
}

func (bm *Bitmap) Set(bit int) {
	ibit := bit / 8;
	if (ibit + 1 > len(bm.bitmap)) {
		bm.bitmap = append(bm.bitmap, make([]C.uint8_t, ibit+1-len(bm.bitmap))...)
	}
	
	bm.bitmap[ibit] |= 1 << (uint(bit) & 7)
}

func (bm *Bitmap) SetRange(start int, end int) {
	for i := start; i <= end; i++ {
		bm.Set(i)
	}
}

func (bm *Bitmap) Clear(bit int) {
	ubit := uint(bit)
	if (bit > bm.Max()) {
		return
	}
	
	bm.bitmap[bit / 8] &= ^(1 << (ubit & 7))
}

func (bm *Bitmap) ClearRange(start int, end int) {
	for i := start; i <= end; i++ {
		bm.Clear(i)
	}
}

func (bm *Bitmap) Max() (int) {
	return len(bm.bitmap) * 8
}

func (bm *Bitmap) IsEmpty() (bool) {
	for i:=0; i<len(bm.bitmap); i++ {
		if bm.bitmap[i] != 0 {
			return false
		}
	}
	return true
}

func (a Bitmap) And(b Bitmap) (c Bitmap) {
	var max, min int
	if len(a.bitmap) > len(b.bitmap) {
		max = len(a.bitmap)
		min = len(b.bitmap)
	} else {
		max = len(b.bitmap)
		min = len(a.bitmap)
	}
	c.bitmap = make([]C.uint8_t, max)

	for i := 0; i < min; i++ {
		c.bitmap[i] = a.bitmap[i] & b.bitmap[i]
	}
	return
}

// const char *libxl_scheduler_to_string(libxl_scheduler p);
// int libxl_scheduler_from_string(const char *s, libxl_scheduler *e);
func (s Scheduler) String() (string) {
	cs := C.libxl_scheduler_to_string(C.libxl_scheduler(s))
	// No need to free const return value

	return C.GoString(cs)
}

func SchedulerFromString(name string) (s Scheduler, err error) {
	cname := C.CString(name)
	defer C.free(unsafe.Pointer(cname))

	var cs C.libxl_scheduler

	ret := C.libxl_scheduler_from_string(cname, &cs)
	if ret != 0 {
		err = fmt.Errorf("libxl_scheduler_from_string failed: %d", ret)
		return
	}

	s = Scheduler(cs)

	return
}

// libxl_cpupoolinfo * libxl_list_cpupool(libxl_ctx*, int *nb_pool_out);
// void libxl_cpupoolinfo_list_free(libxl_cpupoolinfo *list, int nb_pool);
func (Ctx *Context) ListCpupool() (list []CpupoolInfo) {
	var nbPool C.int

	c_cpupool_list := C.libxl_list_cpupool(Ctx.ctx, &nbPool)

	defer C.libxl_cpupoolinfo_list_free(c_cpupool_list, nbPool)

	if int(nbPool) == 0 {
		return
	}

	// Magic
	cpupoolListSlice := (*[1 << 30]C.libxl_cpupoolinfo)(unsafe.Pointer(c_cpupool_list))[:nbPool:nbPool]

	for i := range cpupoolListSlice {
		var info CpupoolInfo
		
		info.Poolid = uint32(cpupoolListSlice[i].poolid)
		info.PoolName = C.GoString(cpupoolListSlice[i].pool_name)
		info.Scheduler = Scheduler(cpupoolListSlice[i].sched)
		info.DomainCount = int(cpupoolListSlice[i].n_dom)
		info.Cpumap = bitmapCToGo(&cpupoolListSlice[i].cpumap)

		list = append(list, info)
	}

	return
}

// int libxl_cpupool_create(libxl_ctx *ctx, const char *name,
//                          libxl_scheduler sched,
//                          libxl_bitmap cpumap, libxl_uuid *uuid,
//                          uint32_t *poolid);
// FIXME: uuid
// FIXME: Setting poolid
func (Ctx *Context) CpupoolCreate(Name string, Scheduler Scheduler, Cpumap Bitmap) (err error, Poolid uint32) {
	poolid := C.uint32_t(0)
	name := C.CString(Name)
	defer C.free(unsafe.Pointer(name))
	
	// For now, just do what xl does, and make a new uuid every time we create the pool
	var uuid C.libxl_uuid
	C.libxl_uuid_generate(&uuid)

	cbm := bitmapGotoC(Cpumap)
	defer C.libxl_bitmap_dispose(&cbm)
	
	ret := C.libxl_cpupool_create(Ctx.ctx, name, C.libxl_scheduler(Scheduler),
		cbm, &uuid, &poolid)
	// FIXME: Proper error
	if ret != 0 {
		err = fmt.Errorf("libxl_cpupool_create failed: %d", ret)
		return
	}

	Poolid = uint32(poolid)
	
	return
}

// int libxl_cpupool_destroy(libxl_ctx *ctx, uint32_t poolid);
func (Ctx *Context) CpupoolDestroy(Poolid uint32) (err error) {
	ret := C.libxl_cpupool_destroy(Ctx.ctx, C.uint32_t(Poolid))
	// FIXME: Proper error
	if ret != 0 {
		err = fmt.Errorf("libxl_cpupool_destroy failed: %d", ret)
		return
	}

	return
}

// int libxl_cpupool_cpuadd(libxl_ctx *ctx, uint32_t poolid, int cpu);
func (Ctx *Context) CpupoolCpuadd(Poolid uint32, Cpu int) (err error) {
	ret := C.libxl_cpupool_cpuadd(Ctx.ctx, C.uint32_t(Poolid), C.int(Cpu))
	// FIXME: Proper error
	if ret != 0 {
		err = fmt.Errorf("libxl_cpupool_cpuadd failed: %d", ret)
		return
	}

	return
}

// int libxl_cpupool_cpuadd_cpumap(libxl_ctx *ctx, uint32_t poolid,
//                                 const libxl_bitmap *cpumap);
func (Ctx *Context) CpupoolCpuaddCpumap(Poolid uint32, Cpumap Bitmap) (err error) {
	cbm := bitmapGotoC(Cpumap)
	defer C.libxl_bitmap_dispose(&cbm)
	
	ret := C.libxl_cpupool_cpuadd_cpumap(Ctx.ctx, C.uint32_t(Poolid), &cbm)
	// FIXME: Proper error
	if ret != 0 {
		err = fmt.Errorf("libxl_cpupool_cpuadd_cpumap failed: %d", ret)
		return
	}

	return
}

// int libxl_cpupool_cpuremove(libxl_ctx *ctx, uint32_t poolid, int cpu);
func (Ctx *Context) CpupoolCpuremove(Poolid uint32, Cpu int) (err error) {
	ret := C.libxl_cpupool_cpuremove(Ctx.ctx, C.uint32_t(Poolid), C.int(Cpu))
	// FIXME: Proper error
	if ret != 0 {
		err = fmt.Errorf("libxl_cpupool_cpuremove failed: %d", ret)
		return
	}

	return
}

// int libxl_cpupool_cpuremove_cpumap(libxl_ctx *ctx, uint32_t poolid,
//                                    const libxl_bitmap *cpumap);
func (Ctx *Context) CpupoolCpuremoveCpumap(Poolid uint32, Cpumap Bitmap) (err error) {
	cbm := bitmapGotoC(Cpumap)
	defer C.libxl_bitmap_dispose(&cbm)
	
	ret := C.libxl_cpupool_cpuremove_cpumap(Ctx.ctx, C.uint32_t(Poolid), &cbm)
	// FIXME: Proper error
	if ret != 0 {
		err = fmt.Errorf("libxl_cpupool_cpuremove_cpumap failed: %d", ret)
		return
	}

	return
}

// int libxl_cpupool_rename(libxl_ctx *ctx, const char *name, uint32_t poolid);
// int libxl_cpupool_cpuadd_node(libxl_ctx *ctx, uint32_t poolid, int node, int *cpus);
// int libxl_cpupool_cpuremove_node(libxl_ctx *ctx, uint32_t poolid, int node, int *cpus);
// int libxl_cpupool_movedomain(libxl_ctx *ctx, uint32_t poolid, uint32_t domid);
// int libxl_cpupool_info(libxl_ctx *ctx, libxl_cpupoolinfo *info, uint32_t poolid);

//
// Utility functions
//
func (Ctx *Context) CpupoolFindByName(name string) (info CpupoolInfo, found bool) {
	plist := Ctx.ListCpupool()

	for i := range plist {
		if plist[i].PoolName == name {
			found = true
			info = plist[i]
			return
		}
	}
	return
}

func (Ctx *Context) CpupoolMakeFree(Cpumap Bitmap) (err error) {
	plist := Ctx.ListCpupool()

	for i := range plist {
		var Intersection Bitmap
		Intersection = Cpumap.And(plist[i].Cpumap)
		if ! Intersection.IsEmpty() {
			err = Ctx.CpupoolCpuremoveCpumap(plist[i].Poolid, Intersection)
			if err != nil {
				return
			}
		}
	}
	return
}

func XlTest(Args []string) {
	var Ctx Context

	err := Ctx.Open()
	if err != nil {
		fmt.Printf("Opening context: %v\n", err)
		return
	}

	pool, found := Ctx.CpupoolFindByName("schedbench")

	if found {
		fmt.Printf("Found schedbench, destroying\n")

		err = Ctx.CpupoolDestroy(pool.Poolid)
		if err != nil {
			fmt.Printf("Couldn't destroy pool: %v\n", err)
			return
		}

		fmt.Printf("Returning cpus to pool 0 for fun\n")
		err = Ctx.CpupoolCpuaddCpumap(0, pool.Cpumap)
		if err != nil {
			fmt.Printf("Couldn't add cpus to domain 0: %v\n", err)
			return
		}
	}

	var Cpumap Bitmap

	Cpumap.SetRange(12, 15)

	fmt.Printf("Freeing cpus\n")
	err = Ctx.CpupoolMakeFree(Cpumap)
	if err != nil {
		fmt.Printf("Couldn't free cpus: %v\n", err)
		return
	}


	fmt.Printf("Creating new pool\n")

	err, Poolid := Ctx.CpupoolCreate("schedbench", SchedulerCredit, Cpumap)
	if err != nil {
		fmt.Printf("Error creating cpupool: %v\n", err)
	} else {
		fmt.Printf("Pool id: %d\n", Poolid)
	}

	Ctx.Close()
}
